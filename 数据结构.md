

# 线性表
## 基本概念及操作
- 线性表的基本操作

```c
设L=（a1,a2, ...ai-1, ai , ai+1, …, an ）是一线性表
1   初始化操作 InitList(&L) 
功能：建立空的线性表L；
2   销毁操作 DetroyList(&L)
功能：回收为线性表L动态分配的存储空间；
3   置空操作 ClearList(&L)
功能：L中已存在，重新将其置成空表；
4   判空操作 ListEmpty(L)
功能：判断线性表L是否为空表，若为空表返回TRUE，否则返回FALSE；
5   求表长操作 ListLength(L)
功能：返回线性表L的表长；
6   取元素操作：GetElem(L, i, &e)
功能：将线性表L中第i 个元素赋值给 e；
7   查找操作 LocateElem (L, e,compare() )
功能：在线性表L中查找与元素e满足compare()的第1个元素，返回该元素在表中的序号（或位置），若表中不存在这样的元素，则返回0；
8   插入操作 ListInsert(&L, i, e )
功能：在线性表L的第i个元素之前插入一个新元素e;
9   删除操作 ListDelete(&L, i, &e )
功能：删除线性表L的第i个元素，并用e返回；
10 遍历操作 ListTraverse (&L,visit( ) )
功能：依次对线性表L的每一个元素调用函数visit( )。若visit( )失败，则返回ERROR，否则返回OK；

```
## 顺序存储及实现
- 顺序表的类型定义
```c
#define   LIST_INIT_SIZE   100    //  线性表存储空间的初始分配量#define   LISTINCREMENT   10   // 线性表存储空间的分配增量
typedef struct{
	ElemType   * elem;     //线性表存储空间基址
	int    length;    //当前线性表长度
	int    listsize;     //当前分配的线性表存储空间大小（以sizeof(ElemType)为单位）
}SqList;
```
- 顺序表的基本操作算法
```c
Status InitList_Sq(SqList &L){
     //构造一个空的顺序表L
      L.elem=(ElemType*)malloc(LIST_INIT_SIZE*sizeof(ElemType));
	if (! L.elem) exit(OVERFLOW);  //存储分配失败
    L. length=0;  //空表长度为0
    L.listsize=LIST_INIT_SIZE; //初始存储容量
    Return OK;
}//InitList_Sq
Status DetroyList_Sq ( SqList &L) {
    If (!L.elem) return ERROR;  // 若表L不存在      
    free (L.elem);           // 若表L已存在，回收动态分配的存储空间
    L.elem = null;      
    L.length = 0;      
    L.Listsize = 0;      
    return OK;
}// DetroyList_Sq
Status ClearList_Sq ( SqList &L) {
    If (!L.elem) return ERROR;  // 若表L不存在      
    L.length = 0;         //若表L已存在，将L置空      
    return OK;
}// ClearList_Sq
Status GetElem_Sq ( SqList &L, int i, ElemType &e ) {
    If ((i< 1)||( i > L.length )) 
    return ERROR;  //  i 非法      
    e = L.elem [ i-1 ];    //将顺序表中第i 个元素赋值给 e      
    return OK;
}// GetElem_Sq 
Status ListInsert_Sq(SqList &L, int i , ElemType e) {
//在顺序表L中第i个位置之前插入新的元素e,// i的合法值为1≤i≤L.length+1,当i =L.length+1时
//  e插在表尾
	if (i<1|| i>L.length+1) 
	return ERROR; // i值不合法
	if (L.length>=L.listsize) 
	return ERROR; //顺序表已满
	for ( j=L.length-1 ; j>= i-1; --j) {
		L.elem[j+1]= L.elem[ j]; //插入位置及之后的元素后移一个位置
		L.elem[i-1] =e; 
	 }  //插入e++L.length; //表长增1
	return OK;
}//ListInsert_Sq
Status ListInsert_Sq(SqList &L, int I, ElemType e) {
    //在顺序表L中第i个位置之前插入新的元素e,    //i的合法值为1≤i≤L.length+1
    if (i<1|| i>L.length+1) 
    return ERROR; //i值不合法     
    if (L.length>=L.listsize) 
    return ERROR; //顺序表已满     
    q=&(L.elem[ i-1]);  //q为插入位置     
    for (p=&(L. elem[L.length-1]){ 
	    p>=q;
        --p)*(p+1)=*p;     //插入位置及之后的元素后移一个位置     
        *q=e;   //插入e     
        ++L.length;
	}//表长加1     
    return OK;
}//ListInsert_Sq 
Status ListDelete_Sq(SqList &L, int i, ElemType &e) {     //在顺序表L中删除第 i个元素，并用e返回其值     //   i的合法值为  1≤i≤L.length，//  表空L.length=0 则i> L.length
    if ((i<1)||(i>L.length)) 
    return ERROR; // i值不合法或表空     
    e = L.elem[i-1];    // 被删除元素的值赋给e     
    for ( j= i; j<= L.length-1; ++j) 
    L.elem[j-1] = L.elem[ j];  //被删除元素之后的元素前移      
    --L.length; //表长减1      
	return OK;
}//ListDelete_Sq
Status ListDelete_Sq(SqList &L, int I, ElemType &e) {      //在顺序线性表L中删除第.i个元素，并用e返回其值      // i的合法值为  1≤i≤L.length// 表空L.length=0 则i> L.length      
	if((i<1)||(i>L.Length))
    return ERROR; // i值不合法或表空      
	p=&(L.elem[i-1]);    //p为被删除元素的位置      
    e=*p;// 被删除元素的值赋给e      
    q=L.elem[L.length-1];// 表尾元素的位置      
    for (++p; p<=q;++p)*(p-1)=*p;  //被删除元素之后的元素前移
    --L.length; //表长减1      
    return OK;
}//ListDelete_Sq
  ```
-  算法时间复杂度分析

- 归并：将两个有序线性表归并成一个有序线性表
```c
Void MergeList_Sq(SqList La, SqList Lb, SqList &Lc){      //已知顺序表La和Lb中的数据元素按值非递减排列。     //归并La和Lb得到新的顺序表Lc,Lc的数据元素也按值非递减排列。
	InitList_Sq(Lc)；
	i=j=1;
	k=0;    
	La_len=Listength_Sq(La); 
	Lb_len=ListLength_Sq(Lb);    
	while((.i<=La_len)&&(j<=Lb_len)){//La和Lb均非空	
		GetElem_Sq(La, i, ai); 
		GetElem_Sq(Lb, j, bj);
		if(ai<=bj) {
			ListInsert_Sq(Lc, ++k, ai); 
			++i;
		}
	    else {
		    ListInsert_Sq(Lc, ++k, bj); 
		    ++j;
	    }     
}    
	while(i<=La_len) {
	    GetElem_Sq(La, .i++, ai); 
	    ListInsert_Sq(Lc, ++k, ai);     
    }     
	while(j<=Lb_len){
	    GetElem_Sq(Lb, .j++, bj);
	    ListInsert_Sq (Lc, ++k,bj);
    }
}//MergeList_Sq      
void MergeList_Sq(SqList La, SqList Lb, SqList &Lc){     //已知顺序表La和Lb的元素按值非递减排列     //归并La和Lb得到新的顺序表Lc,Lc的元素也按值非递减排列     
	pa=La.elem; 
	pb=Lb.elem;
	Lc.listsize=Lc.length=La.length+Lb.length;
				pc=Lc.elem=(ElemType*)malloc(Lc.listsize*sizeof(ElemType));
	if(!Lc.elem)exit(OVERFLOW);//存储分配失败     
	pa_last=La.elem+La.length-1;     
	pb_last=Lb.elem+Lb.length-1;
	while(pa<=pa_last &&pb<=pb_last){
    //归并          
	if(*pa<=*pb)*pc++=*pa++;         
	else *pc++=*pb++;      
	}     
	while (pa<=pa_last)*pc++=*pa++; //插入La的剩余元素     
	while (pb<=pb_last)*pc++=*pb++; //插入Lb的剩余元素}//MergeList_Sq  

Status ListInsert_Sq(SqList &L, int I, ElemType e) {
      //在顺序线性表L中第i个位置之前插入新的元素e,
      // i的合法值为1≤i≤ListLength_Sq(L)+1
    if (,I<1||.i>L.length+1)return ERROR; //.i值不合法
    if (L.length>=L.listxize){ //当前存储空间已满，重新分配空间
          newbase=(ElemType*)realloc(L. .elem,
                          (L.listsize+LISTINCREMENT)*sizeof (ElemType));
          if (!newbase)exit(OVERFLOW);  //存储分配失败
          L. elem=newbase; //新基址
          L.listsize+=LISTINCREMENT; //增加存储容量
      }
    q=&(L.elem[i-1]);  //q为插入位置
    for (p=&(L. elem[L.length-1]); p>=q ; --p)*(p+1) = *p;
      //插入位置及之后的元素右移
    *q=e; //插入e
    ++L.length; //表长增1
    return OK;
}//ListInsert_Sq   
```
## 链式存储及实现
### 线性链表
- 结点定义类型
```c
typedef struct  Lnode{
    ElemType   data;
    Struct  Lnode  *next;
}LNode, *LinkList;
```
- 线性链表基本操作的算法 
```c
Status InitList_L (LinkList &L) {
    L = (LinkList)malloc(sizeof(Lnode));
    If (!L) exit(OVERFLOW);
	L->next = null;       
    Return OK;
}// InitList_L  
Status GetElem_L(LinkList L, int I, ElemType &e){
     //L为带头结点的单链表的头指针。
     //当第i个元素存在时，其值赋给e并返回OK，否则返回ERROR
     p=L->next; j=1;  //初始化，p指向第一个结点，j为计数器
     while(p&& j<i){  //顺指针向后查找，直到p指向第i个元素或p为空
              p=p->next;++j;
      }
      if (!p||j>i)return ERROR; //第i个元素不存在
      e=p->data;  //取第i个元素
      return OK;
}//GetElem_L
Status ListInsert_L(LinkList &L, int i, ElemType e){
      //在带头结点的线性链表L中第I元素结点之前插入元素e
      p=L; j=0
      while (p&&j<i-1){p=p->next; ++j;}//寻找第i-1个元素结点
      if(!p||j>i-1)return ERROR; // i小于1或者大于表长
      s=(LinkList)malloc(sizeof(LNode));// 分配新结点
       s->data=e;
       s->next=p->next; p->next=s;   //插入新结点
       return OK;
}//LinstInsert_L
Status ListDelete_L(LinkList &L, int i, ElemType &e){
       //在带头结点的单链线性表L中，删除第i个元素，并由e返回其值
       p=L; j=0;
       while (p->next&&j<i-1){  //寻找第i个结点，并令p指向其前趋
             p=p->next; ++j;
       }
       if(!p->next)||j>i-1)return ERROR; //  表中无第i个结点(i不合法)
       q=p->next;p->next=q->next;   //删除结点
       e =q->data; free(q);                //  回收（释放）结点空间
       return OK;
}//LinstDelete_L

```
- 静态链表(  ?  )
```c
#define  MAXSIZE   1000   // 链表的最大长度
typedef struct{
ElemType   data; 
int        cur;
} component, SLinkList[MAXSIZE];
void  InitSpace_SL(SLinkList &space){
      // 将一维数组space中各分量连成一个备用链，space[0].cur为头指针
      //’0’表示空指针
       for (i=0; i<MAXSIZE-1; ++i) space[i].cur=i+1;
       space[MAXSIZE-1].cur=0;
}//Initspace_SL
int   Malloc_SL(SLinkList &space){
      //  若备用链非空，则返回分配的结点下标，否则返回0
        i=space[0].cur;
        if (space [0].cur) space[0].cur=space[i].cur;
        return i;
}//Malloc_SL
void  Free_SL(SLinkList &space, int k ){
      // 将下标为k的空闲结点回收到备用链上
       space[k].cur=space[0].cur; space[0].cur=k;
}// Free_SL
void  difference(SLinkList &space, int &S ){
      // 在一维数组space中建立集合(A-B)U(B-A),s为头指针
      // space[0].cur为备用链的头指针
    Initspace_SL(space);  //建立备用链
    s=Malloc_SL(space);  //生成s的头结点
    r=s;
    scanf(m,n);
    for (j=1; j<=m; ++j){
        i=Malloc_SL(space);
        scanf(space[i].data);
        space[r].cur=i; r=i;
    }//for   //建立集合A的链表
	space[r].cur=0;   //尾结点的指针用0表示
    for (j=1; j<=n; ++j)   {  //依次输入B的元素，并在表中查找
      Scanf(b); 
      p=s; 
      k=space[s].cur;
		While  (k!=space[r].cur && space[k].data!=b){  //在表中查找
	     P=k ; 
	     k=space[k].cur;
		}// while
		if (k==space[r].cur){   //该元素不存在插入在r 所指结点之后，且r的位置不变
		    i=Malloc_SL(space); 
		    space[i].data=b; 
		    space[i].cur=space[r].cur;   
		    space[r].cur=i  ;
	    }//if
	    else {         //该元素已存在，则删除之
	        space[p].cur=space[k].cur ;
	        Free_SL(space,k);
	        if (r==k)  
		        r=p; //若删除的元素是尾元素，则需要修改尾指针
	    }//else
	}//for
}//difference
 


```
- 归并
```c
void MergeList_L(LinkList &La, LinkList &Lb, LinkList &Lc) {
//已知线性链表La和Lb的元素按值非递减排列//归并La和Lb得到新的线链性表Lc,Lc的元素也按值非递减排列。
pa=La->next; pb=Lb->next;Lc=pc=La;  //用La的头结点作为Lc的头结点
while(pa && pb){
If (pa->data<=pb->data){
	pc->next=pa;
	pc=pa;
	pa=pa->next;
	}
else {
	pc->next=pb;
	pc=pb;
	pb=pb->next;
	}
}
pc->next=pa?pa:pb;//插入剩余段free(Lb);//释放Lb的头结点
}//MergeList_L
```
### 循环链表
### 双向链表
```c
Status ListInsert_DuL(DuLinkList &L, int i, ElemType e){//在带头结点的双向循环链表L中第i个位置之前插入元素e，//i的合法值为1≤i≤表长+1。
if(!p=GetElemP_DuL(L,i))) //在L中确定第i个元素的位置指针p
	return ERROR; //p=NULL，即第i个元素不存在//建新结点、
if (!(s=(DuLinkList)malloc(sizeof(DuLNode))))
    return ERROR;
    s->data=e;
    s->prior=p->prior;
    p->prior->next=s;   // 完成插入图示中的①②
    s->next=p; p->prior=s;     //完成插入图示中的③④
return OK;
}//LinstInsert_DuL
Status ListDelete_DuL(DuLinkList &L, int i, ElemType&e){
//删除带头结点的双向循环链表L的第i个元素，i的合法值为1≤i≤表长
if(!p=GetElemP_DuL(L,i))) //在L中确定第i个元素的位置指针p
	return ERROR; //p=NULL，第i个元素不存在
	e = p->data;
	p->prior->next=p->next;  //完成删除图示中的①  
	p->next->prior=p->prior;   //完成删除图示中的② 
	free(p);
	return OK;
}//LinstDelete_DuL
```
## 应用
- 一元多项式的表示及相加(代码略)
# 栈
## 栈的概念
- 栈的基本操作
```c
1） 初始化操作InitStack(&S)  功能：构造一个空栈S；
2） 销毁栈操作DestroyStack(&S)  功能：销毁一个已存在的栈; 
3） 置空栈操作ClearStack(&S)  功能：将栈S置为空栈;
4） 取栈顶元素操作GetTop(S, &e)  功能：取栈顶元素，并用e 返回;
5） 进栈操作Push(&S, e)功能：元素e进栈;
6） 退栈操作Pop(&S, &e) 功能：栈顶元素退栈，并用e返回;
7） 判空操作StackEmpty(S) 功能：若栈S为空，则返回True，否则返回False;

```
## 栈的顺序存储
-顺序栈类型定义
```c
#define  STACK_INIT_SIZE  100  // 栈存储空间的初始分配量
#define  STACKINCREMENT   10   //  栈存储空间的分配增量
typedef struct{
SElemType  *base;     //栈空间基址
SElemType  *top;    //栈顶指针
int stacksize;     //当前分配的栈空间大小
                   //（以sizeof(SElemType)为单位）
}SqStack;

Status InitStack_Sq(SqStack &S)  {       //构造一个空栈S     
S.base=(SElemType * )malloc(STACK_INIT_SIZE *sizeof(SElemType)); //为顺序栈动态分配存储空间      
if (! S. base) exit(OVERFLOW);    //存储分配失败
S.top=S.base;      
S.stacksize=STACK_INIT_SIZE;
return OK;
}//InitStack_Sq
Status DetroyStack_Sq ( SqStack &S) {
    If (!S.base) return ERROR;  //  若栈未建立（尚未分配栈空间）   
    free (S.base);                        // 回收栈空间    
    S.base = S.top = null;
	S.stacksize = 0;     
    return OK;
}// DetroyStack_Sq
Status ClearStack_Sq ( SqStack &S) {
    If (!S.base) return ERROR;  // 若栈未建立（尚未分配栈空间）
    S.top = S.base ;
    return OK;
}// ClearStack_Sq
Status GetTop_Sq(SqStack S, SelemType &e) {
       // 若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回ERROR 
    if (S.top= =S.base)  return ERROR; //若栈为空 
    e = * (S.top-1);
    return OK;
}//GetTop_Sq
Status Push(SqStack &S, SElemType e) {
      //将元素e插入栈成为新的栈顶元素 
      if (S.top-S.base>=S.stacksize) {//栈满，追加存储空间      
      S.base= (SElemType * )realloc(S.base,(S.stacksize +STACKINCREMENT) * sizeof(ElemType));  
          if (! S. base) exit(OVERFLOW);  //存储分配失败        
	          S.top=S.base+S.stacksize;       
	          S.stacksize+=STACKINCREMENT;      
	          }     
	*S.top++=e;     //元素e 插入栈顶，修改栈顶指针     
	return OK;
}//Push
Status Pop(SqStack &S, SElemType &e) {       //若栈不空，则删除S的栈顶元素，用e 返回其值，并返回OK；
      //否则返回ERROR      
	      if (S.top= = S.base) return ERROR;  //栈空，返回ERROR
	      e = * --S.top;//删除栈顶元素，用e 返回其值，并修改栈顶指针     
	      return OK;
}//Pop
```
## 栈的链式存储
## 应用
### 数制转换(代码略)
### 表达式求值(代码略)
### 递归 (代码略)
# 队列
## 队列的概念
-  队列的基本操作
```c
1）初始化操作InitQueue( &Q)      功能：构造一个空队列Q；
2）销毁操作DestroyQueue( &Q)      功能：销毁已存在队列Q；
3）置空操作ClearQueue(&Q)      功能： 将队列Q置为空队列 ；
4）判空操作QueueEmpty(Q)       功能：若队列Q为空，则返回True，否则返回False；
5）取队头元素操作GetHead(Q,&e)      功能：取队头元素，并用e返回；
6）入队操作EnQueue( &Q, e )       功能：将元素e插入Q的队尾；
7）出队操作DeQueue( &Q,  &e)       功能：若队列不空，则删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR；
```
## 队列的顺序存储(循环队列)
- 顺序队列的类型定义

```c
#define  MAXSIZE 100  //  最大队列长度
typedef struct{
    QElemType  *base;     //初始化时动态分配存储空间的基址
    int front;    //队头指针，指向队头元素
    int rear;     //队尾指针，指向队尾元素的下一个位置
}SqQueue;

```
- 队空队满的判别
- 循环队列的基本操作算法
```c
1）初始化操作InitQueue_Sq(SqQueue &Q) 
  参数：Q是存放队列的结构变量；
  功能：建一个空队列Q；
  算法：
Status InitQueue_Sq(SqQueue &Q) {
       //构造一个空队列Q
	Q.base=(ElemType * )malloc (MAXSIZE *sizeof (ElemType));
	if (!Q.base) exit (OVERFLOW);   //存储分配失败      
    Q.front = Q.rear=0;
    Return OK;
}// InitQueue_Sq
2）入队操作EnQueue_Sq(SqQueue  &Q, QElemType  e )
     功能：将元素e插入队尾 ；
     入队操作主要步骤：
   1）Q是否已满， 若满，返回ERROR；否则转2）；
   2）将元素e 写入队尾；
   3）修改队尾指针，使队尾指针指向队尾元素的下一个位置；
Status EnQueue_Sq(SqQueue  &Q, QElemType  e )  //将元素e插入队尾
    if ((Q.rear+1)%MAXSIZE= =Q.front) return ERROR ;        
    Q.base[Q.rear] = e ;      // 将元素e插入队尾
    Q.rear= (Q.rear+1)%MAXSIZE;    // 修改队尾指针
    return OK;
}// EnQueue_Sq
3）出队操作DeQueue_Sq (SqQueue  &Q, QElemType  &e )
     功能：删除队头元素，用e返回其值 ；
     出队操作主要步骤：
   1）Q是否为空， 若空，返回ERROR；否则转2）；
   2）将队头元素赋值给e；
   3）修改队头指针，删除队头元素；
Status DeQueue_Sq(SqQueue  &Q, QElemType &e )        //删除队头元素，用e返回其值,并返回OK；否则返回ERROR
    if ((Q.rear= =Q.front) return ERROR ;
    e =Q.base[Q.front] ;      // 将元素e取出
    Q.ftont= (Q.front+1)%MAXSIZE;    // 修改队尾指针
    return OK;
}// EnQueue_Sq

```
## 队列的链式存储
- 链队列的类型定义
```c
typedef struct QNode{    //链队列结点的类型定义
    QElemType  data;         
    struct QNode *next;
}QNode,*QueuePtr;
typedef struct {          //链队列的表头结点的的类型定义    
	QueuePtr front;//队头指针，指向链表的头结点     
	QueuePtr rear;      //队尾指针，指向队尾结点
}LinkQueue;

```
- 链队列的基本操作算法
```c
Status InitQueue_L(LinkQueue &Q) {
       //建一个空队列Q      
	Q.from=Q.rear=(QueuePtr)malloc(sizeof(QNode));  //为链队列的头结点分配空间 
    if (!Q.front) exit(OVERFLOW);     
    Q.front->next=NULL;       
    return OK;
} //InitQueue_L 
Status DestroyQueue_L(LinkQueue &Q)  {           //销毁队列Q
    if (!Q.front) return ERROR; // 链队列不存在
    while(Q.front->next) {          // 回收链队列的所有元素结点空间               
	    p=Q.front->next;                           
	    Q.front->next=p->next;
	    free(p);
	}
    free(Q.front);                       // 回收链队列头结点空间
    Q.front=Q.rear=null;
    return OK;
}//DestroyQueue_L
Status EnQueue_L(LinkQueue &Q, QElemType ) {
     //在链队列Q队尾，插入新的队尾结点   
	p=(QueuePtr)malloc(sizeof(QNode));   //为新元素e分配结点空间 
	if (!p) exit (OVERFLOW);     //存储分配失败     
	p->date=e; p->next=NULL;    
	Q.rear->next=p;           //修改队尾指针，插入新队尾结点
	Q.rear=p;               
	return OK;
}
）出队操作
Status DeQueue_L(LinkQueue &Q, QElemType &e)  {        //若队列不空，则删除Q的队头元素结点，用e返回其值，并返回OK；        //否则返回ERROR        
if (Q.front = =Q.rear) return ERROR;    //若队列空，返回ERROR
        p=Q.front->next; // p指向队头元素结点        
        e=p->data;        
        Q.front->next=p->next; // 修改链队列头结点指针，则删除队头元素结点              
        if(Q.rear= =p)                                                 Q.rear=Q.front; // 对于链队列只有一个元素结点的情况要同时修改队尾指针
        free(p);                                                       return OK;
}
```
## 应用
- 解决计算机主机与外设不匹配的问题；
- 解决由于多用户引起的资源竞争问题；
- 离散事件的模拟----模拟实际应用中的各种排队现象；
- 用于处理程序中具有先进先出特征的过程
# 树
## 树的有关概念
- 树的概念
- 树的应用
- 树的表示
- 树的基本术语
- 树的基本操作
```c
 1）InitTree(&T);
 2）DestroyTree(&T);
 3）CreateTree(&T, definition);
 4）ClearTree(&T);
 5）TreeEmpty(T);
 6）TreeDepth(T); 
 7） Root(T);
 8） Value(T, &cur_e);
 9） Assign(T, cur_e, value);
 10）Paret(T, cur_e);
 11）LeftChild(T, cur_e);
 12）RightSibling(T, cur_e);
 13）InsertChild(&T, &p, i, c);
 14）DeleteChild(&T,&p, i);
 15）TraverseTree(T, Visit( ));

```
## 二叉树概念
- 二叉树定义
	- 普通二叉树
	- 满二叉树
	- 完全二叉树
- 二叉树性质
	- 在二叉树的第i 层上最多有2i-1个结点
	- 性质2 深度为k的二叉树最多有 2k-1 个结点(k≥1)
	- 性质3  对任意一棵二叉树，如果叶子结点个数为n0，度为2的结点个数为n2，则有n0=n2+1。
	- 性质4  具有n个结点的完全二叉树高度为log2(n)+1 或 log2（n+1） (注意x表示取不大于x的最大整数，也叫做对x下取整，x表示取不小于x的最小整数，也叫做对x上取整。)
	- 性质5. 如果对一棵有n个结点的完全二叉树（深度为log2 n+1 ）的结点按层序编号（从第一层到第log2 n+1层，每层从左到右），则对任一结点i（1 1≤i≤n)有： 
		- （1）若 i=1，则结点i为二叉数的根结点，无双亲；如果i>1,则其双亲PARENT(i) 是 i/2；
		- （2）如果2i>n，则i无左孩子(结点i为叶子结点）；否则其左孩子结点LCHILD(i)为2i。 
		- （3）如果2i+1>n，则i无右孩子；否则其右孩子结点RCHILD(i)为2i+1。  
- 二叉树存储结构
	- 顺序结构
	- 链式结构
		- 二叉链表
		 ```c
		二叉链表类型说明
		typedef struct Bitnode{
			Telemtype   data;
			struct Bitnode *lchild, *rchild;
		}Bitnode,*Bitree;

		  ```
		- 三叉链表
		- 静态链表
## 二叉树遍历与线索二叉树
### 二叉树遍历
- 先序递归算法
- ```c
  void PreOrderTraverse(BiTree T, Status(*Visit)(TElemType  e)) {//采用二叉链表存贮二叉树， visit( )是访问结点的函数。
      //先序遍历二叉树T的递归算法，对每个数据元素调用函数Visit( ) 
	if (T) {  //若二叉树为空，结束返回   //  若二叉树不为空，访问根结点；遍历左子树，遍历右子树
    Visit(T->data)；      
    PreOrderTraverse(T->lchild, Visit);
    PreOrderTraverse(T->rchild, Visit); 
}//if}//PreOrderTraverse
  ```
- 中序递归算法
- ```c
  void InOrderTraverse(BiTree T, Status(*Visit)(TElemType  e)) {  //采用二叉链表存贮二叉树， visit( )是访问结点的函数。
 //中序遍历二叉树T，对每个数据元素调用函数Visit( ) 
 if (T) {//若二叉树为空，结束返回   //  若二叉树不为空，遍历左子树，访问根结点，遍历右子树   
	 InOrderTraverse(T->lchild, Visit);
     Visit(T->data)；     
     InOrderTraverse(T->rchild, Visit);    }//if
}// InOrderTraverse   
  ```
- 后序递归算法
- ```c
  void PostOrderTraverse(BiTree T, Status(*  Visit)(TElemType  e)) {  //采用二叉链表存贮二叉树， visit( )是访问结点的函数。
 //中序遍历二叉树T，对每个数据元素调用函数Visit( ) 
 if (T) {//若二叉树为空，结束返回   //  若二叉树不为空，遍历左子树，遍历右子树，访问根结点    
	 PostOrderTraverse(T->lchild, Visit);     
	 PostOrderTraverse(T->rchild, Visit);
     Visit(T->data)；     
     }//if
 }//PostOrderTraverse   
  ```
  - 中序非递归遍历
  - ```c
void inorder(BiTree T) {
//二叉链表存贮二叉树
	InitStack(S); Push(S,T);
	while (!StackEmpty(S)){
	    while (GetTop(S,p)&&p)  
		    Push(S,p->lchild);//到二叉树的最左端
		    Pop(S,p);//空指针退栈
		if(!StackEmpty(S)) {                 //访问结点，向右一步
		    Pop(S,p);
		    Printf(p->data);
	        Push(p->rchild);
	    }//if
   }//while
}//inorder
    ```
 - 先序非递归遍历
   -  ```c
    void preorder(BiTree T) {
//二叉链表存贮二叉树
  InitStack(S); 
  Push(S,T);//根入栈
  while (!StackEmpty(S)){
     Pop(S,p);
      Visit(p);
      if(p->rchild)
	Push(S,p->rchild);
      if(p->lchild)
	Push(S,p->lchild);
      }//while
}//preorder

    ```
- 后序非递归遍历（略）
- 遍历应用：编写 求二叉树结点个数的算法
- ```c
  void leaf(BiTree T) {
//采用二叉链表存贮二叉树，n为全局变量，用于累加二叉树的结点
//的个数。本算法在先序遍历二叉树的过程中，统计结点的个数
//第一 次被调用时，n=0
if(T) {                               //若二叉树为空，结束返回       //若二叉树不为空，在先序遍历二叉树的过程中，
         //统计结点的个数
       n=n+1;
       leaf(T->lchild);
       leaf(T->rchild);
      }//if
}//leaf
viod PreOrderTraverse(BiTree T, Status(*Visit)(TElemType  e)) {//采用二叉链表存贮二叉树， visit( )是访问结点的函数。
      //先序遍历二叉树T，对每个数据元素调用函数Visit( ) if (T) {                       //若二叉树为空，返回   //  若二叉树不为空，访问根结点；遍历左子树，遍历右子树
     Visit(T->data)；      
     PreOrderTraverse(T->lchild, Visit);     
     PreOrderTraverse(T->rchild, Visit); }//if
}//PreOrderTraverse
void leaf(BiTree T) {
//采用二叉链表存贮二叉树，n为全局变量，用于累加二叉树的结点,的个数。
//本算法在先序遍历二叉树的过程中，统计结点的个数第一 次被调用时，n=0
   if(T) {                               //若二叉树为空，结束返回     //若二叉树不为空，在先序遍历二叉树的过程中，统计结点的个数 
          visi(T->data); n=n+1;
         leaf(T->lchild); 
         leaf(T->rchild);  
   }//if
}//leaf
  ```
  - 为二叉树建立二叉链表
```c
Status CreateBiTree(BiTree &T)  {
//输入（在空子树处添加*的二叉树的）先序序列（设每个元素是一个字
// 符）按先序编历的顺序，建立二叉链表，并将该二叉链表根结点指针
//赋给T
     scanf (&ch);
    if (ch= = ‘* ’) T=NULL;                        // 若ch= = ‘*’ 则T=NULL返回
    else  {                                                  //   若ch! = ‘*’ 
         if (! (T=(BiTNode * )malloc(sizeof(BiTNode))))  exit(OVERFLOW);
         T->date = ch;                       // 建立（根）结点 
         CreateBiTree(T->lchild);  //构造左子树链表，并将左子树根结点指针
                                                  //赋 给（根）结点 的左孩子域
         CreateBiTree(T->rchild);   //构造右子树链表，并将右子树根结点指针
                                                    //赋给（根）结点 的右孩子域
     }
     return  OK;
}//CreateBiTree

```
### 线索二叉树
-  线索链表的类型说明
- ```c
typedef enum{link,thread}PointerTag;  //link=0, thread=1
typedef struct BiThrNode{
    TElemType       data;
    Struct BiThrNode  *lchild, *rchild;    //左右指针域
    PointerTag        Ltag, Rtag;   //左右标志域，标志域为0时，表示左右指针//域存储的是左右孩子的指针，标志域为1时，表示左右指针域存储的是
//前趋后继结点的指针
} BiThrNode，*BiThrTree
  ```
## 树、森林
- 双亲表示类型定义
- ```c
    #define MAX_TREEE_SIZE  100
typedef struct PTNode{
    TelemType  data;
    int   parent;   //双亲位置域
}PTNode;
typedef struct{
    PTNode nodes[MAX_TREE_SIZE];
    Int   n;   //结点数
}Ptree;
  ```
- 树的孩子链表类型定义
- ```c
typedef struct CTNode{     //孩子结点
     int    child;
     struct CTNode * next;
}* ChildPtr;
typedef struct{
     TElemType data;
     ChildPtr firstchild;   //孩子链表头指针
}CTBox;
typedef struct{
    CTBox nodes[MAX_TREE_SIZE];
    Int   n, r;   //结点数和根的位置；
}CTree;
  ```
-  孩子兄弟表示法类型定义
- ```c
   typedef struct CSNode{
     TElemType   data;
     struct CSNode  *firstchild, * nextsibling;
}CSNode, *CSTree;

  ```
### 森林与二叉树转换
- 二叉链表
### 树与森林遍历
#### 树的遍历
- 先根遍历
- 后根遍历
#### 森林遍历
- 先序遍历
- 中序遍历
## 树与二叉树的应用
### 哈夫曼树
#### 概念及构造
#### 哈夫曼编码
#### 哈夫曼编码算法
- 存储哈夫曼树的静态三叉链表类型定义
- ```c
typedef struct {
	unsigned int weight;
	unsigned int parent, lchild, rchild;
}HTNode, *HuffmanTree;            //动态分配数组存储哈夫曼树
  ```
  - 哈夫曼算法
  - ```c
void HuffmanTree(HuffmanTree &HT,  int * w, int n){
//w 存放n 个字符的权值（均>0），构造赫夫曼树HT
if (n<=1) return;
	m=2* n-1;
	HT=(HuffmanTree)malloc(m+1) * sizeof(HTNode); 
//空间为哈夫曼树分配存储
for  (p=HT+1, i=1; i<=n; ++i, ++p, ++w)  
	* p={ * w, 0, 0, 0};   //用给定的n个权//值 ，构造n棵只有一个根结点的二叉树
for (; i<=m; ++i; ++p) {     //按构造哈夫曼树的步骤2、3、4，建哈夫曼树
//在HT[1..i-1] 选择parent为0且weight最小的两个结点，其序号分别为s1和//s2。
	Select(HT, i-1, s1, s2);
	HT[s1]. parent =i;  HT[s2].parent=i;   //HT[i]存放新子树的根结点，
	HT[i].lchild=s1;  HT[i].rchild=s2;
	HT[i].weight=HT[s1].weight+HT[s2].weight;
//申请了n+1一个元素的数组，每个元素都是指向一个字符数组的指针
	HC=(HuffmanCode)malloc((n+1)*sizeof(char *));
	cd=(char*)malloc(sizeof(char)*n);
	cd[n-1]='\0';//最后一个为结束标志
//从叶子到根进行逆向编码，输出的时候正向输出
for(i=1;i<=n;i++)
{	start=n-1;
	for(j=i;j<m;j=HT[j].parent)		
	//m是最后的根,探测的时候当前节点只能在前一个就结束
		if(HT[HT[j].parent].lchild= =j)
			cd[--start]='0';
		else
			cd[--start]='1';
	HC[i]=(char*)malloc((n-start)*sizeof(char));
	strcpy(HC[i],&cd[start]);
}
free(cd);

    ```
%%### 并查集%%
# 图
## 图的概念
-   图的基本操作
- ```c
1  CreateGraph(&G, V, VR);
初始条件：V是图的顶点集，VR是图中弧的集合
操作结果：按V和VR的定义构造图G
2 DestroyGraph(&G);
初始条件：图G存在
操作结果：销毁图G
3 LocateVex(G,u);
初始条件：图G存在，u和G中顶点有相同特征
操作结果：若G中存在顶点u，则返回该顶点在图中位置；否则返回其它信息。
4 GetVex(G, v);
初始条件：图G存在，v是G中某个顶点
操作结果：返回v的值
5 PutVex(&G, v, value);
初始条件：图G存在，v是G中某个顶点
操作结果：对v赋值value
6 FirstAdjVex(G, v);
初始条件：图G存在，v是G中某个顶点
操作结果：返回v的第一个邻接顶点。若顶点在G中没有邻接顶点，则返回“空”。
7 NextAdjVex(G, v, w);
初始条件：图G存在，v是G中某个顶点，w是v的邻接顶点。
操作结果：返回v的（相对于w的）下一个邻接顶点。若w是v的最后一个邻接点，则返回“空”。
8 InsertVex(&G, v);
初始条件：图G存在，v和图中顶点有相同特征。
操作结果：在图G中增添新顶点v
9 DeleteVex(&G, v);
初始条件：图G存在，v和图中顶点有相同特征
操作结果：删除G中顶点v及相关的弧
10 InsertArc(&G, v, w); 
初始条件：图G存在，v和w是G中两个顶点。
操作结果：在G中增添弧<v,w>，若G是无向的，则还增添对称弧<w,v>
11 DeleteArc(&G, v, w);
初始条件：图G存在，v和w是G中两个顶点。
操作结果：在G中删除弧<v,w>，若G是无向的，则还删除对称弧<w,v>
12 DFSTraverse(G, v, Visit( ));
初始条件：图G存在，v是G中某个顶点，Visit是顶点的应用函数。
操作结果：从顶点v起深度优先遍历图G，对每个顶点调用函数Visit一次且仅一次。一旦visit( )失败，则操作失败
13 BFSTraverse(G, v, Visit( ));
初始条件：图G存在，v是G中某个顶点，Visit是顶点的应用函数。
操作结果：从顶点v起广度优先遍历图G，对每个顶点调用函数Visit一次且一次。一旦visit( )失败，则操作失败
  ```
## 图的存储结构
### 数组表示法
- 数组表示法类型定义
- ```c
#define MAX_VERTEX_NUM   m    //最大顶点个数
typedef enum {DG,DN,UDG,UDN}GraphKind;  //{有向图，有向网，无向图，无向网}
typedef struct ArcCell {       
VRType  adj;    //VRType 是顶点关系类型。对无权图，用1或0
//表示相邻否；对带权图，则为权值类型。
}ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];
typedef struct {
VertexType vexs[MAX_VERTEX_NUM];    //存储顶点的一维数组
AdjMatrix arcs;             //存储邻接矩阵的二维数组
int  vexnum, arcnum;    //图的当前顶点数和弧数
GraphKind  kind;  //图的种类标志
}Mgraph;
  ```
  
```c
  //获得顶点u的序号
int LocateVex(MGraph G,VertexType u)
{	for(i=0;i<G.vexnum;i++) 
		if(strcmp(G.vexs[i],u)==0) return i;
	return -1;
}
//获得v的第一个邻接顶点的序号
//存在邻接顶点则返回其在数组中序号，否则返回-1
int FirstAdjVex(MGraph G,VertexType v)
{	i=LocateVex(G,v);
	if(G.kind%2）
		k=INFINITY;
	for(j=0;j<G.vexnum;j++)
		if(G.arcs[i][j].adj!=k)
			return j;
	return -1;		
}
//获得图中V顶点的w邻接顶点之后的下一个顶点的序号
int NextAdjVex(MGraph G,VertexType v,VertexType w)
{
	a=LocateVex(G,v);
	b=LocateVex(G,w);
	if(G.kind%2)
		k=INFINITY;
	for(i=b+1;i<G.vexnum;i++)
		if(G.arcs[a][i].adj!=k)
			return i;
	return -1;
}
//插入图中一个顶点
void InsertVex(MGraph &G,VertexType v)
{	j=0;
	if(G.kind%2)
		j=INFINITY;
	for(i=0;i<=G.vexnum;i++)
	{
		G.arcs[G.vexnum][i].adj=j;
		G.arcs[i][G.vexnum].adj=j;
	}
	strcpy(G.vexs[G.vexnum],v);
	G.vexnum++;
}
Status DeleteVex(MGraph &G,VertexType v)
{	j=0;
	k=LocateVex(G,v);
	//把k之后所有元素向前移动一个
	for(i=k+1;i<G.vexnum;i++) 
		strcpy(G.vexs[i-1],G.vexs[i]);
	if(G.kind%2)	
		j=INFINITY;
	if(k<0)
		return ERROR;
	//移动待删除顶点右边矩阵元素
	for(i=0;i<G.vexnum;i++)
		for(j=k+1;j<G.vexnum;j++)
			G.arcs[i][j-1]=G.arcs[i][j];
	//移动待删除顶点下边矩阵元素
	for(i=0;i<G.vexnum;i++)
		for(j=k+1;j<G.vexnum;j++)
			G.arcs[j-1][i]=G.arcs[j][i];
	G.vexnum--;
	return OK;
}
Status InsertArc(MGraph &G,VertexType va,VertexType vb)
{	va1=LocateVex(G,va);	vb1=LocateVex(G,vb);
	if(va1<0||vb1<0) return ERROR;
	G.arcnum++; 	//弧边数目加1
	if(G.kind%2)//网
	{	printf("请输入弧对应的权");
		scanf("%d",&G.arcs[va1][vb1].adj);
	}else
		G.arcs[va1][vb1].adj=1;
	if(G.kind>1)//无向图
	{
		G.arcs[va1][vb1].adj=G.arcs[vb1][va1].adj;
		G.arcs[va1][vb1].info=G.arcs[vb1][va1].info;
	}
	return OK;
}
Status DeleteArc(MGraph &G,VertexType v,VertexType w)
{	j=0;
	if(G.kind%2)
		j=INFINITY;
	v1=LocateVex(G,v);  
	w1=LocateVex(G,w);
	if(v1<0||w1<0||v1==w1) 
		return ERROR;
	G.arcs[v1][w1].adj=j;
	if(G.kind>=2)//无向
		G.arcs[w1][v1].adj=j;
	G.arcnum--;
	return OK;
}

```
### 邻接表
- 图的邻接表类型定义
```c
#define MAX_VERTEX_NUM  20
struct ElemType{
	int adjvex;		//该弧所指向的顶点序号
	InfoType *info;	//弧权值，通常直接指向一个数值变量
};
typedef struct ArcNode{    //边（弧）结点的类型定义
	ElemType data;   //边（弧）的另一顶点的在数组中位置及权值
	struct ArcNode  *nextarc; //指向下一条边（弧）结点的指针
}ArcNode;
typedef struct Vnode {  //顶点结点和数组的类型定义
	VertexType data;       //顶点信息
	ArcNode   * finrstarc;  //指向关联该顶点的边（弧）链表
}Vnode, AdjList[MAX_VERTEX_NUM];
typedef struct {
	AdjList  vertices;
	int  vexnum, arcnum;    //图的当前顶点数和弧数
	int   kind;    //图的种类标志
}ALGraph;
```

```c
/*获得指定顶点元素的首个邻接顶点序号*/
int FirstAdjvex(ALGraph G,VertexType v)
{
	int i;
	i=LocateVex(G,v);
	if(G.vertices[i].firstarc)
		return G.vertices[i].firstarc->data.adjvex;
	else
		return -1;
}

```
### 十字链表
tailvex:弧尾在图中的位置
headvex:弧头在图中的位置
hlink:指向弧头相同的下一条弧
tlink:指向弧尾相同的下一条弧
data:和顶点相关的信息
fitstin:指向以该顶点为弧头的第一条弧
firstout:指向以该顶点为弧尾的第一条弧
### 邻接多重表
mark:标志域
ivex、jvex: 边（Vi,Vj)所依附的顶点Vi和Vj在图中的位置
ilink :指向下一条依附于ivex的边
jlink :指向下一条依附于jvex的边
data:和顶点相关的信息
fitstedge:指向依附于该顶点的边
## 图的遍历
```c
Boolean visited[MAX_VERTEX_NUM]  
//访问标志数组,全局变量，初始值：所有分量全为False(0)
//visited[v]=TRUE表示顶点v已被访问
```
### BFS
```c
深度优先遍历算法
void DFS(Graph G, int v, Status(*Visit(int v))  {
// 从第v个顶点出发，递归地深度优先遍历图G。 
 // v是顶点在一维数组中的位置，假设G是非空图
visited[v] =TRUE; Visit(v);   //访问第v个顶点
for (w= FirstAdjVex(G, v);  w; w=NextAdjVex(G, v, w))
if (!visited[w])   DFS(G, w);    //对v的尚未访问的邻接顶点w递归调用DFS
```
### DFS
```c
void BFSTraverse(Graph G,int v,Status (*  Visit)(int v))  {
//从v出发，广度优先遍历连通图G。 v是顶点在一维数组中的位置，使用辅助队列Q和访问标志数组visited。 
 for (u=0; u< G.vexnum; ++u) visited[u]=FALSE;
 InitQueue(Q);  //建空的辅助队列Q
 Visited[v]=TRUE; Visit(v)，EnQueue(Q,v) //访问v,v入队
 While(!QueueEmpty(Q)){
      DeQueue(Q,u);   //队头元素出队,并赋值给u
      //访问u所有未被访问的邻接点
      for(w=FirstAdjVex(G,u); w; w=NextAdjVex(G,u,w))
          if(!visited[w]){          // 若w尚未访问
             Visited[w]=TRUE; Visit(w);EnQueue(Q,w);
          }//if
 }//while
}//BFSTraverse
```
### 非连通图的遍历
```c
算法(**)：
For (v=0;v<=G.vexnum;++v) visited[v]=false;
For (v=0;v<=G.vexnum;++v)
    if (!visited[v]) DFS(G,v);
```

## 图的应用
### 最小生成树
#### prim算法
```C
算法: 网用邻接矩阵表示
Viod MiniSpanTree_prim(Mgraph G, Vertextype u){ 
// 用prim算法从第u个顶点出发构造网G的最小生成树T,输出T的各条边。
// closedge的定义
// struct {
//         Vertextype  adjvex;//依附于u中的顶点
//          Vrtype    lowcost;//最小的权值
//}closedge[MAX_VERTEX_NUM];　
K=locatevex(G,u);　  
for (j=1,j<=G.vexnum;++j) //辅助数组初始化
    if (j!=k) closedge[j]={u,G.arcs[k][j].adj};//{adjvex,lowcost}
Closedge[k].lowcost=0;  // 初始 U={u}
for (i=1; i<G.vexnum ; ++i)　{  
   k=mininum(closedge);   //  选择具有最小代价的边，//closedge[k].lowcost=MIN{closedge[vi].lowcost | //closedge[vi].lowcost>0, viV-U}
   printf(closedge[k].adjvex, G.vexs[k]); // 输出生成树的边
   closedge[k].lowcost=0;  // 将顶点k并入U
   for (j=1; j<=G.vexnum; ++j)
       if (G.arcs[k][j].adj< closedge[j].lowcost)  
            closedge[j]={G.vexs[k],G.arcs[k][j].adj};  // 新顶点并入U后重// 新计算closedge的值
  } // for
}// Minispantree
```
#### kruskal算法
```c
void Kruskal(MGraph G)
{	//构造集合数组set[MAX_VERTEX_NUM]，开始时候各个顶点单独构成连通分量
	for(i=0;i<G.vexnum;i++)
		set[i]=i;
	k=0;
	while(k<G.vexnum-1)//一共要搜寻出vexnum-1条边把所有顶点连接起来
	{
		min=INFINITY;
		//在邻接矩阵中搜寻出代价最小的边(a,b)
		G.arcs[a][b].adj=minimum(G.arcs)	
		//合并两个集合并输出这个边	
		if(set[a]!=set[b])
		{	for(m=0;m<G.vexnum;m++)
				if(set[m]==set[b]) set[m]=set[a]; 	
			printf(G.vexs[a],G.vexs[b]);
			k++;
		}
		G.arcs[a][b].adj=INFINITY; //舍弃这个边
```
### 最短路径
####Dijkstra
```c

```
### 拓扑排序
```c
void FindInDegree(ALGraph G,int indegree[])
{
	for(i=0;i<G.vexnum;i++)
		indegree[i]=0;

	for(i=0;i<G.vexnum;i++)
	{
		p=G.vertices[i].firstarc;
		while(p)
		{
			indegree[p->data.adjvex]++;
			p=p->nextarc;
		}
	}
}

```
```c
Status TopologicalSort(ALGraph  G)  {
//有向图G采用邻接表存储结构。
//若G无回路，则输出G的顶点的一个拓扑序列并返回OK，否则ERROR。
   FindInDegree(G,  indegree);      //求各顶点入度indegree[0..vernum-1]
   InitStack(S);
   For(i=0; i<G. vexnum-1; ++i)     //建入度为0的顶点栈S  
   if (! Indegree[i])  Push(S, i);    //入度为0顶点的编号进栈
  count=0;      //对输出顶点计数
  while(! StackEmpty(S)){ 
       Pop(S, i);        //从零入度顶点栈S 栈顶，获得一入度为零的顶点i
       printf(i, G. vertices[i].data);  ++count;    //输出i号顶点的数据，并计数
       for (p=G. vertices[i]. firstarc;   p;  p=p->nextarc)  {
          k=p->adjvex; 
         if (!(- -indegree[k])) Push(S, k);                         //对i号顶点邻接到的               //每个顶点入度减1，若入度减为0，则入栈
       }//for
  }//while
  if (count<G.vexnum)   return   ERROR;   //该有向图有回路
  else return OK;
}//TopologicalSort

```
### 关键路径
```c
int indegree[MAX_VERTEX_NUM];//存放各个顶点的入度
int ve[MAX_VERTEX_NUM];//定义存放每个顶点事件最早发生的时间
int vl[MAX_VERTEX_NUM];//定义存放每个顶点事件最迟发生的事件

void FindInDegree(ALGraph G,int indegree[])
{//扫描所有弧得到各个顶点的入度
	for(i=0;i<G.vexnum;i++)
		indegree[i]=0;
	for(i=0;i<G.vexnum;i++)
	{	p=G.vertices[i].firstarc;
		while(p)
		{	indegree[p->data.adjvex]++;
			p=p->nextarc;
		}
	}
}
Status TopologicalOrder(ALGraph G,LinkStack &T)
{
	FindInDeree(G,indegree);
	count=0；//计数器
	InitLinkStack(S);//初始化栈
//初始化各个事件最早发生时间为0	
	for(i=0;i<G.vexnum;i++) ve[i]=0;		
	for(i=0;i<G.vexnum;i++)if(!indegree[i]) Push(S,i);//入度为0顶点入栈S	
	//拓扑排序同时计算出所有事件最早发生时间登记到ve[]数组中
	while(!StackEmpty(S))
	{	Pop(S,j);Push(T,j);++count;//j号顶点入栈反向排序
		for(p=G.vertices[e].firstarc;p;p=p->nextarc){
			k=p->adjvex;//对j号顶点的每个邻接点的入度减1
			if(--indegree[k]= =0)	push(s,k);//入度为0的进栈
			if(ve[j]+ *(p->info)>ve[k]) ve[k]=ve[j]+ *(p->info)
		}//for
	}//while
	if(count<G.vexnum) return ERROR;		
	return OK;
}
Status CriticalPath(ALGraph G)
{	if(!TopologicalOrder(G,T)) return ERROR;
	 //初始化顶点事件的最迟发生时间为工程的最后完成时间
	vl[0..G.vexnum-1]=ve[G.vexnum-1];
	while(!stackEmpty(T))//按拓扑逆序求各个顶点事件的最迟发生时间
		for(Pop(T,j),p=G.vertices[j].firstarc;p;p=p->nextarc){
			k=p->adjvex;dut=*(p->info);
			if(vl[k]-dut<vl[j])  vl[i]=vl[k]-dut;
		}//for
	for(j=0;j<G.vexnum;++j)
		for(p=G.vertices[j].firstarc;p;p=p->nextarc){
			k=p->adjvex;dut=*(p->info);
			ee=ve[j];el=vl[k]-dut;
			tag=(ee==el)?’*’:’’;
			printf(j,k,dut,ee,el,tag);
		}//for
}//CriticalPath

```
# 查找
## 基本概念

### 静态查找

### 动态查找
### 平均查找长度
## 线性结构
### 顺序查找
```c
  search(st,key，n)
//在有n个数据的表st中找key
  {  i=n-1;
     while(i>=0 && st[i]!=key)
          i- -;
     if(i<0) return -1;
       //查找不成功返回-1
     else return i;
      //查找成功返回下标号
   }
  search1(st,key，n)
  {   st[0]=key;
      i=n;
    while(st[i]!=key)
          i- -;
        return i;
  //查找返回序号，0为不成功
   }

```
### 折半查找
```c
bin_search(st[],key,n)
   {  low=0; 
        hight=n-1;
        mid=(low+high)/2;
      
     while(low<=high)
      if( st[mid] = = key)
          return mid;
      else  if(st[mid]>key)
           high=mid-1;
     else low=mid+1;
     return -1;
   }
递归：
bin_search(st[],key,l,h)
   {  
      if(l<=h) {
        mid=(l+h)>>1;
          if( st[mid] = = key)
          return mid;
      else  if(st[mid]>key)
          return  bin_search(st,key,l,h-1);
        else 
        eturn bin_search(st,key,l+1,h)
    }
   else return -1;
 }

```
### 分块查找(无代码)
## 树形结构
### 二叉排序树
```c
BiTree SearchBST(BiTree T, KeyType key) {
//二叉排序树用二叉链表存储。在根指针T所指二叉排序树中递归地查找//关键字等于key的记录，若查找成功，则返回该记录结点的指针，否则  //返回空指针
   if(!T)|| EQ(key, T->data. key) return(T);   // 若T为空或查找成功，返回
   else if LT(key, T->data. key)
           return(SearchBST(T->1child, key)); //在左子树中继续查找
           return(SearchBST(T->rchild, key))  //在右子树中继续查找
}//SearchBST

```
### 二叉平衡树(无代码)
### B树（没讲）
## 哈希结构
### 概念
### 构造方法
- 直接定址法
- 数字分析法
- 平方取中法
- 折叠法
- 除留余数法
### 解决冲突方法
- 开放地址法
- 再哈希法
- 链地址法
- 公共溢出区
### 查找
# 内部排序
## 基本概念
## 稳定性
## 时空复杂度
## **插入排序**
### 直接插入排序
```c
void InsertSort(SqList &L)   {
//对顺序表L作直接插入排序。
For (i=2; i<=L. length; ++i){    
       if LT(L.r[i].key, L.r[i-1].key){  //若L.r[i].key < L.r[i-1].key，需将L.r[i]插入有序子表，
        L.r[0]=L.r[i];                       // L.r[i]复制为哨兵
        for(j=i-1; LT(L.r(0).key, L.r[j].key);  --j )        //从后向前查找子表
               L.r[j+1]=L.r[j];           //  若L.r[i].key < L.r[j].key， L.r[j]记录后移
        L.r[j+1]=L.r[0];          //插入到正确位置
}
}//InsertSort

```
%%### 折半插入排序（二分排序）%%
%%### （表插入排序）%%
### 希尔排序
## 交换排序
### 冒泡排序
```c
void Bubblesort(int a[],int n){
  for  ( i=n-1;change=true; i>1&&change; --i){
     change=false; 
     for (j=0; j<i; ++j)  
      if (a[j]>a[j+1])	  { //发生逆序    ElemType t=R[j];
	{a[j]<-->a[j+1];
	change=true; } //交换，并标记发生了交换
      }
}      

```
### **快速排序**
## **选择排序**
### 简单选择排序（直选排序）
```c
void SelectSort(SqList &K) {
//对顺序表L作简单选择排序。
  for (i=1; i<L.length; ++i){      
       j=SelectMinKey(L, i);             //在L.r[i..L.length] 中选择key最小的记录
       if(i!=j)L.r[i]←→L.r[j];            //与第个i记录交换
  }//for
}//SelectSort

```
%%### （树型排序）%%
### 堆排序

